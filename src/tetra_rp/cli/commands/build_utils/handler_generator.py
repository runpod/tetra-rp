"""Generator for handler_<name>.py files."""

import importlib.util
import logging
from pathlib import Path
from typing import Any, Dict, List

logger = logging.getLogger(__name__)

HANDLER_TEMPLATE = '''"""
Auto-generated handler for resource: {resource_name}
Generated at: {timestamp}

This file is generated by the Flash build process. Do not edit manually.
"""

from tetra_rp.runtime.generic_handler import create_handler

# Import all functions/classes that belong to this resource
{imports}

# Function registry for this handler
FUNCTION_REGISTRY = {{
{registry}
}}

# Create configured handler
handler = create_handler(FUNCTION_REGISTRY)

if __name__ == "__main__":
    import runpod
    runpod.serverless.start({{"handler": handler}})
'''


class HandlerGenerator:
    """Generates handler_<name>.py files for each resource config."""

    def __init__(self, manifest: Dict[str, Any], build_dir: Path):
        self.manifest = manifest
        self.build_dir = build_dir

    def generate_handlers(self) -> List[Path]:
        """Generate all handler files."""
        handler_paths = []

        for resource_name, resource_data in self.manifest.get("resources", {}).items():
            handler_path = self._generate_handler(resource_name, resource_data)
            handler_paths.append(handler_path)

        return handler_paths

    def _generate_handler(
        self, resource_name: str, resource_data: Dict[str, Any]
    ) -> Path:
        """Generate a single handler file."""
        handler_filename = f"handler_{resource_name}.py"
        handler_path = self.build_dir / handler_filename

        # Get timestamp from manifest
        timestamp = self.manifest.get("generated_at", "")

        # Generate imports section
        imports = self._generate_imports(resource_data.get("functions", []))

        # Generate function registry
        registry = self._generate_registry(resource_data.get("functions", []))

        # Format template
        handler_code = HANDLER_TEMPLATE.format(
            resource_name=resource_name,
            timestamp=timestamp,
            imports=imports,
            registry=registry,
        )

        handler_path.write_text(handler_code)

        # Validate that generated handler can be imported
        self._validate_handler_imports(handler_path)

        return handler_path

    def _generate_imports(self, functions: List[Dict[str, Any]]) -> str:
        """Generate import statements for functions."""
        imports = []

        for func in functions:
            module = func.get("module")
            name = func.get("name")

            if module and name:
                imports.append(f"from {module} import {name}")

        return "\n".join(imports) if imports else "# No functions to import"

    def _generate_registry(self, functions: List[Dict[str, Any]]) -> str:
        """Generate function registry dictionary."""
        if not functions:
            return "    # No functions registered"

        registry_lines = []

        for func in functions:
            name = func.get("name")
            registry_lines.append(f'    "{name}": {name},')

        return "\n".join(registry_lines)

    def _validate_handler_imports(self, handler_path: Path) -> None:
        """Validate that generated handler has valid Python syntax.

        Attempts to load the handler module to catch syntax errors.
        ImportErrors for missing worker modules are logged but not fatal,
        as those imports may not be available at build time.

        Args:
            handler_path: Path to generated handler file

        Raises:
            ValueError: If handler has syntax errors or cannot be parsed
        """
        try:
            spec = importlib.util.spec_from_file_location("handler", handler_path)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
            else:
                raise ValueError("Failed to create module spec")
        except SyntaxError as e:
            raise ValueError(f"Handler has syntax errors: {e}") from e
        except ImportError as e:
            # Log but don't fail - imports might not be available at build time
            logger.debug(f"Handler import validation: {e}")
        except Exception as e:
            # Only raise for truly unexpected errors
            logger.warning(f"Handler validation warning: {e}")
